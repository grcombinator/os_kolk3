# os_kolk3

## Классические поведенческие шаблоны проектирования

Поведенческие шаблоны решают проблемы взаимодействия объектов, обеспечивая *гибкость*, *переиспользуемость* и *уменьшение связанности* через:

+ Инкапсуляцию поведения в отдельные объекты.
+ Разделение ответственности ("разделяй и властвуй").
+ Ортогональные стратегии (независимые модули, минимизация побочных эффектов).

Рассмотрим три шаблона с примерами и анализом многопоточности.



## Шаблон "Команда" (Command)

Шаблон "Команда" инкапсулирует запрос как объект, позволяя параметризовать клиентов с различными запросами, очередями или логами запросов и поддерживать отмену операций. Он включает в себя три основных компонента:

+ Команда (Command) — интерфейс для выполнения операции.
+ Конкретные команды (ConcreteCommand) — классы, которые реализуют интерфейс команды и определяют действие.
+ Получатель (Receiver) — объект, который знает, как выполнить действие, связанное с командой.

### Проблема:

+ Жесткая связь между инициатором действия (клиентом) и исполнителем.
+ Необходимость отмены операций, очереди запросов или логирования.

### Решение:

Инкапсуляция запроса в объект, позволяющий параметризовать клиентов с различными запросами, ставить их в очередь или поддерживать отмену.

### Примеры:

1. Графический редактор – кнопки меню (интерфейс) вызывают команды (например, "Сохранить"), не зная деталей реализации.
2. Транзакции БД – команды ```Commit``` и ```Rollback``` инкапсулируют операции, позволяя отменять изменения.
3. Очередь задач – асинхронное выполнение команд в многопоточной среде (например, пул потоков).

### Многопоточность:

+ Команды могут быть потокобезопасными, если не разделяют изменяемое состояние.
+ Очереди команд требуют синхронизации (например, ```BlockingQueue``` в Java).

## Шаблон "Стратегия" (Strategy)

Шаблон "Стратегия" определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Этот шаблон позволяет изменять алгоритмы независимо от клиентов, которые их используют. Основные компоненты:

+ Контекст (Context) — класс, который использует стратегию.
+ Стратегия (Strategy) — интерфейс для всех поддерживаемых алгоритмов.
+ Конкретные стратегии (ConcreteStrategy) — классы, реализующие алгоритмы, предоставляемые стратегией.

### Проблема:

+ Множество условных ветвей для выбора алгоритма
+ Жесткая привязка к конкретной реализации

### Решение:

Инкапсуляция семейства алгоритмов в отдельные классы, делая их взаимозаменяемыми.

### Примеры:

1. Сортировка данных – выбор между ```QuickSort```, ```MergeSort``` и ```BubbleSort``` через единый интерфейс ```SortStrategy```.
2. Оплата в приложении – стратегии ```CreditCardPayment```, ```PayPalPayment```, ```CryptoPayment```
3. Навигация – выбор маршрута (```WalkingRoute```, ```DrivingRoute```) в картографическом сервисе.

### Многопоточность:

+ Каждая стратегия должна быть потокобезопасной, если используется совместно.
+ Отсутствие общего состояния минимизирует риски.

## Шаблон "Шаблонный метод" (Template Method)

Шаблон "Шаблонный метод" определяет общий алгоритм в базовом классе, позволяя подклассам переопределять некоторые шаги алгоритма, не изменяя его структуру. Основные компоненты:

+ Абстрактный класс (AbstractClass) — определяет шаблонный метод и может содержать абстрактные методы для переопределения.
+ Подклассы (ConcreteClass) — реализуют абстрактные методы и могут добавлять дополнительные шаги в алгоритм.

### Проблема:

+ Повторение кода в похожих алгоритмах с незначительными вариациями

### Решение:

Вынесение общего алгоритма в базовый класс, оставляя подклассам возможность переопределения отдельных шагов.

### Примеры:

1. Игра-стратегия – базовый класс ```GameAI``` определяет общий цикл (```buildUnits()```, ```attack()```), а подклассы (```OrcAI```, ```HumanAI```) уточняют логику.
2. Обработка документов – шаблонный метод ```generateReport()``` с переопределяемыми ```fetchData()``` и ```formatData()```.
3. Юнит-тесты – ```setUp()``` и ```tearDown()``` в фреймворках (JUnit, pytest)

### Многопоточность:

+ Потокобезопасность зависит от реализации переопределяемых методов
+ Базовый алгоритм может синхронизировать критические секции


## Архитектура ПО и влияние многопоточности

Архитектура ПО – это фундаментальная организация системы, включающая:

+ Компоненты и их взаимодействие.
+ Принципы принятия решений (масштабируемость, отказоустойчивость).
+ Стили (микросервисы, MVC, Event-Driven).

#### Влияние многопоточности:

1. Сложность управления состоянием – разделяемые ресурсы требуют синхронизации (мьютексы, CAS).

2. Производительность vs. Блокировки – выбор между lock-free структурами и традиционными блокировками.

3. Модель акторов (Erlang, Akka) – изоляция потоков через асинхронные сообщения.

4. Реактивные системы – неблокирующие вызовы (CompletableFuture, RxJava).

### Вывод:

Многопоточность требует явного учета в архитектуре – от выбора парадигмы (потоки, корутины, акторы) до проектирования неизменяемых (immutable) объектов.
